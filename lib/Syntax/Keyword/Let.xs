#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "feature.h"

#include "XSParseKeyword.h"

// Enable assert() macros
#undef NDEBUG
#include <assert.h>

/*
Effect of op flags:

OPpRESTHV : Indicates that a 'rest item' - which is a hash - is on the stack to receive all remaining key/value pairs. Note that it will be with the rest of the target variables.

Context:
void context -> returns nothing, obviously
scalar context -> returns the number of *existing* keys extracted from the source hash
list context -> returns the variables assigned to

Note a key difference with scalar context compared to, say, list assignment. For example:

$count = (my ($dog) = $hash{dog}); # Always 1.
$count = (let ($dog) = %hash); # 1 if and only if exists $hash{dog} - otherwise 0.

If you want to also filter out values that exist but are undefined, use defined() operator:
let ($dog) = %hash; if (defined($dog)) { ... }
*/

/* Order of operators:
LISTOP DESTRUCTURE
	PUSHMARK
	key operators
	PUSHMARK
	target operators (PADSV, PADHV)
	source operator

New destructure operator layout:
LISTOP destructure (Allowed flags: OPf_WANT_VOID, OPf_WANT_SCALAR, OPf_WANT_LIST, OPpRESTAV, OPpRESTHV)
	pushmark -- like all list operators, we start with a pushmark
	One of the following three sequences:
	
	LISTOP nestedlet -- a nestedlet operator
		(OPpRESTAV, OPpRESTHV not allowed in this form)
	OP source OPf_WANT_SCALAR -- an expression, in scalar context
	destructure op itself must be flagged OPf_SPECIAL - this is used to advise that no implicit toplevel operation is occuring.

	sequence of <keypair ops>
	PADOP PADHV OPf_REF
	
	sequence of <keypair ops>
	UNOP RV2HV OPf_REF
		OP source OPf_WANT_SCALAR -- an expression, in scalar context
The first option represents a destructure where the toplevel is entering a referenced array or hash, e.g.:
let [ $x, $y, $z ] = $source; (Equivalent to my ($x, $y, $z) = @$source;)
Or
let { $x, $y, $z } = $source; (Equivalent to my ($x, $y, $z) = @$source{qw/x y z/};)
The second and third represent destructuring from an explicit hash variable or dereferenced hash
(PADHV if it is a lexical hash, RV2HV is used for both global hashes (the 'source' is the GV op) or referenced hashes)
	
A nestedlet opcode consists of the following:
LISTOP nestedlet, must be flagged OPpNESTEDHV or OPpNESTEDAV, and optionally OPpRESTAV or OPpRESTHV
	pushmark -- like all list operators, start with a pushmark
	If flagged OPpNESTEDHV:
		sequence of <keypair ops>
	If flagged OPpNESTEDAV:
		sequence of <target operator>
	If OPpRESTAV:
		PADOP PADAV OPf_REF + OPf_MOD + OPp_LVAL_INTRO
	If OPpRESTHV:
		PADOP PADHV OPf_REF + OPf_MOD + OPp_LVAL_INTRO

A sequence of <keypair ops> is the following sequence:
0 or more occurrences of the following op sequence
	<key operator>
	<target operator>
If OPpRESTAV:
	PADOP PADAV OPf_REF + OPf_MOD + OPp_LVAL_INTRO
If OPpRESTHV:
	PADOP PADHV OPf_REF + OPf_MOD + OPp_LVAL_INTRO

A <key operator> is basically a scalar expression operator. For toplevel destructure and for nestedlet with OPpNESTEDHV, it is stringified and used as a hash key.
	For nestedlet with OPpNESTEDAV, it is numberified and used as an array index.
A <target operator> is generally one of three options:
	OP UNDEF
	PADOP PADSV OPf_REF + OPf_MOD + OPp_LVAL_INTRO -- for stuffing it into a scalar
	PADOP LVREF OPf_REF + OPf_MOD + OPp_LVAL_INTRO -- assignment by reference (formally generated by SREFGEN / LIST / PADSV, which is peepholed into LVREF)
	LISTOP nestedlet - for entering a nested structure
*/

#define OPpRESTHV 0x01 /* indicates that an HV is present to receive leftover items */
#define OPpRESTAV 0x02 /* indicates that an AV is present to receive leftover items */
#define OPpNESTEDHV 0x4 /* type flag for nested destructure entering a hash */
#define OPpNESTEDAV 0x8 /* type flag for nested destructure entering an array */

#define DBG(...) warn(__VA_ARGS__)

MGVTBL vtbl_nestedlen = { 0, 0, 0, 0, 0 }; /* We don't need any of the actual magic functions. */

static SV* create_nestedlen(pTHX_ MAGIC** mg, int items)
{
	AV* obj = newAV();
	av_extend(obj, items);
	
	SV* sv = newSV(0);
	*mg = sv_magicext(sv, MUTABLE_SV(obj), PERL_MAGIC_ext, &vtbl_nestedlen, NULL, 0);
	assert(*mg);
	SvREFCNT_dec(obj); /* The reference is now owned by mg */
	
	return sv;
}

static XOP xop_nestedlet;
static OP* pp_nestedlet(pTHX)
{
	dSP; dMARK;
	const I32 items = SP - MARK;
	
	AV* obj;
	MAGIC* mg;
	SV* sv = create_nestedlen(aTHX_ &mg, items);
	obj = MUTABLE_AV(mg->mg_obj);
	
	for (int i = 0; i < items; ++i)
	{
		SV* item = MARK[i + 1];
		SvREFCNT_inc(item); /* Must increment the count because the AV* needs to own a reference - if an exception occurs, the AV will decrement refcounts of everything still in it */
		av_store(obj, i, item);
	}

	SP = MARK;
	
	mg->mg_private = (U16)(PL_op->op_private);
	
	sv_2mortal(sv); /* Mortalize for insertion into the stack */
	
	XPUSHs(sv);
	
	RETURN;
}

static MAGIC* is_nestedlet(pTHX_ SV* sv)
{
	if (SvTYPE(sv) < SVt_PVMG) return NULL;
	MAGIC* mg = mg_findext(sv, PERL_MAGIC_ext, &vtbl_nestedlen);
	return mg;
}

// This is basically pp_rv2av but functional form and only the part we're actually going to use.
// The array is stuffed into operation ignoring its magic.
// If the source is valid, it's stored into operation and returns 1. If not returns 0.
static bool source_rv2av(pTHX_ SV* operation, MAGIC* opmg, SV* source)
{
	bool is_hash = opmg->mg_private & OPpNESTEDHV;
	const svtype type = is_hash ? SVt_PVHV : SVt_PVAV;
	SvGETMAGIC(source);
	if (SvROK(source))
	{
		if (UNLIKELY(SvAMAGIC(source)))
		{
			source = amagic_deref_call(source, is_hash ? to_hv_amg : to_av_amg);
		}
		source = SvRV(source);
		if (UNLIKELY(SvTYPE(source) != type))
		{
			DBG("Failing, wrong type");
			return 0;
		}
		SV* sv = newRV(source);
		sv_setsv(operation, sv);
		assert(SvROK(operation));
		SvREFCNT_dec(sv);
		return 1;
	}
	return 0;
}

static XOP xop_destructure;
static OP* pp_destructure(pTHX)
{
	dSP; dMARK;
	
	SV* source = POPs;
	AV* opstack = newAV();
	const I32 items = SP - MARK;
	
	I32 result_count = 0; // Total number of assignments of values that exist.
	
	SV* op;
	
	//Perl_croak(aTHX_ "Unimplemented");

	if (PL_op->op_flags & OPf_SPECIAL)
	{
		/* No implicit operation is occuring, so the stack should contain exactly one more operand that is a nestedlen structure. */
		assert(items == 1);
		SV* op = POPs;
		SvREFCNT_inc(op); /* Increment for AV ownership */
		MAGIC* mg = is_nestedlet(aTHX_ op);
		assert(mg);
		source_rv2av(aTHX_ op, mg, source);
		assert(SvROK(op));
		av_push(opstack, op);
	}
	else
	{
		/* Implicit hash operation */
		assert(SvTYPE(source) == SVt_PVHV);
		MAGIC* mg;
		SV* op = create_nestedlen(aTHX_ &mg, items);
		sv_2mortal(op);
		AV* ktp = MUTABLE_AV(mg->mg_obj);
		for (int i = 0; i < items; ++i)
		{
			SV* item = MARK[i + 1];
			SvREFCNT_inc(item); /* Must increment the count because the AV* needs to own a reference - if an exception occurs, the AV will decrement refcounts of everything still in it */
			av_store(ktp, i, item);
		}
		SP = MARK;
		mg->mg_private = PL_op->op_private | OPpNESTEDHV;
		SV* rv = newRV(source);
		rv = sv_2mortal(rv);
		assert(SvROK(rv));
		source_rv2av(aTHX_ op, mg, rv);
		SvREFCNT_inc(op);
		assert(SvROK(op));
		av_push(opstack, op);
	}
	
	// The stack should now be empty, so we are free to push results onto it.
	assert(SP == MARK);

	while (AvFILL(opstack) >= 0)
	{
		SV* op = av_shift(opstack);
		SvREFCNT_dec(op);
		SV* restxv = 0;
		MAGIC* mg = is_nestedlet(aTHX_ op);
		assert(mg);
		assert(SvROK(op));
		source = SvRV(op);
		U16 mode = mg->mg_private;
		AV* obj = MUTABLE_AV(mg->mg_obj);
		
		assert(mode & (OPpNESTEDAV | OPpNESTEDHV));
		
		if (mode & (OPpRESTAV | OPpRESTHV))
		{
			restxv = av_pop(obj);
			SvREFCNT_dec(restxv);
		}
		else
			restxv = 0;
		
		if (mode & OPpNESTEDAV)
		{
			assert(!(mode & (OPpNESTEDHV | OPpRESTHV)));
			assert(SvTYPE(source) == SVt_PVAV);
			SSize_t pos = 0;
			AV* srcav = MUTABLE_AV(source);
			while (AvFILL(obj) >= 0)
			{
				SV* target = av_shift(obj);
				SV** value = av_fetch(srcav, pos++, 0);
				MAGIC* mg2;
				SvREFCNT_dec(target); // The obj array referenced it so now we must unref.
				if (target == &PL_sv_undef)
				{
					// Discarding the value, but we still have to actually retrieve it.
					if (!value || !*value)
					{
						// Element does not exist, skip.
						continue;
					}
					++result_count;
				}
				else if (mg2 = is_nestedlet(aTHX_ target))
				{
					if (value && *value && source_rv2av(aTHX_ target, mg2, *value))
					{
						SvREFCNT_inc(target);
						av_push(opstack, target);
					}
				}
				else
				{
					if (!value || !*value)
					{
						// Element does not exist, set target to undef and skip.
						sv_setsv(target, &PL_sv_undef);
						continue;
					}
					++result_count;
					sv_setsv(target, *value);
				}
			}
			if (restxv)
			{
				assert(SvTYPE(restxv) == SVt_PVAV);
				AV* target = MUTABLE_AV(restxv);
				av_clear(target);
				av_extend(target, AvFILL(srcav) - pos);
				for (; pos <= AvFILL(srcav); ++pos)
				{
					SV** item = av_fetch(srcav, pos, 0);
					SV* elem;
					if (!item || !*item)
						elem = newSV(0);
					else
					{
						elem = newSVsv(*item);
						++result_count;
					}
					av_push((AV*)restxv, elem);
				}
			}
		}
		else
		{
			assert(mode & OPpNESTEDHV);
			assert(SvTYPE(source) == SVt_PVHV);
			HV* srchv = MUTABLE_HV(source);
			HV* rest_keys = 0;
			HE* ent;
			if (restxv)
			{
				rest_keys = newHV();
				sv_2mortal((SV*)rest_keys);
				hv_iterinit(srchv);
				while (ent = hv_iternext(srchv))
				{
					SV* keysv = hv_iterkeysv(ent);
					SV* valsv = hv_iterval(srchv, ent);
					SV* newval = newSVsv(valsv);
					hv_store_ent(rest_keys, keysv, newval, HeHASH(ent));
				}
			}
			while (AvFILL(obj) >= 0)
			{
				MAGIC* mg2;
				SV* keysv = av_shift(obj);
				SvREFCNT_dec(keysv);
				SV* target = av_shift(obj);
				SvREFCNT_dec(target);
				ent = hv_fetch_ent(srchv, keysv, 0, 0);
				SV* valsv = ent ? HeVAL(ent) : NULL;
				if (target == &PL_sv_undef)
				{
					if (valsv) ++result_count;
				}
				else if (mg2 = is_nestedlet(aTHX_ target))
				{
					if (valsv && source_rv2av(aTHX_ target, mg2, valsv))
					{
						SvREFCNT_inc(target);
						av_push(opstack, target);
					}
				}
				else
				{
					if (valsv)
					{
						sv_setsv(target, valsv);
						++result_count;
					}
					else
						sv_setsv(target, &PL_sv_undef);
				}
				if (restxv)
				{
					hv_delete_ent(rest_keys, keysv, G_DISCARD, HeHASH(ent));
				}
			}
			if (restxv)
			{
				if (SvTYPE(restxv) == SVt_PVHV)
				{
					hv_iterinit(rest_keys);
					while (ent = hv_iternext(rest_keys))
					{
						SV* keysv = hv_iterkeysv(ent);
						SV* valsv = hv_iterval(rest_keys, ent);
						SV* newval = newSVsv(valsv);
						hv_store_ent((HV*)restxv, keysv, newval, HeHASH(ent));
						++result_count;
					}
				}
				else
				{
					assert(SvTYPE(restxv) == SVt_PVAV);
					hv_iterinit(rest_keys);
					while (ent = hv_iternext(rest_keys))
					{
						SV* keysv = hv_iterkeysv(ent);
						SV* valsv = hv_iterval(rest_keys, ent);
						SV* newkey = newSVsv(keysv);
						av_push((AV*)restxv, newkey);
						SV* newval = newSVsv(valsv);
						av_push((AV*)restxv, newval);
						++result_count;
					}
				}
			}
		}
	}
	mXPUSHi(result_count);
	
	RETURN;
}

static inline XSParseKeywordPiece* my_next_arg(pTHX_ XSParseKeywordPiece* args[], size_t nargs, size_t* argix)
{
	assert(*argix < nargs);
	//DBG("Retrieving arg %lu", *argix);
	return args[(*argix)++];
}
#define NEXT_ARG (my_next_arg(aTHX_ args, nargs, argix))

static OP* build_let_varlist(pTHX_ XSParseKeywordPiece* args[], size_t nargs, size_t* argix, void* hookdata, int is_hash)
{
	OP* oplist = newLISTOP(OP_LIST, 0, NULL, NULL);
	I32 op_private = 0;
	
	int varct = NEXT_ARG->i;
	int already_complained = 0;
	
	while (varct-- > 0)
	{
		if ((op_private & (OPpRESTHV|OPpRESTAV)) && !already_complained)
		{
			/* If we are even here, it's because we have another destructure element after a "rest" destructure.
			*/
			Perl_qerror(aTHX_ mess("No more variables allowed after slurp target"));
			already_complained = 1;
			//Perl_yyerror(aTHX_ "Expected end of destructure list");
			/* Note that we continue because unless this is an unrecoverable error, we need to still return some kind of optree */
			/* (yyerror can die() out sometimes but that's not our problem anymore) */
		}
		OP* key_op;
		if (is_hash)
		{
			int has_name = NEXT_ARG->i;
			if (has_name)
			{
				int which = NEXT_ARG->i;
				switch (which)
				{
					case 0: /* XPK_IDENT */
					{
						SV* sv_key = NEXT_ARG->sv;
						SvREADONLY_on(sv_key);
						key_op = newSVOP(OP_CONST, (OPpCONST_BARE << 8), sv_key);
					}
					break;
					case 1: /* XPK_BRACESCOPE ( XPK_TERMEXPR ) */
					key_op = op_contextualize(NEXT_ARG->op, G_SCALAR);
					break;
				}
			}
			else key_op = NULL;
		}
		else key_op = NULL;
		int target_type = 1;//NEXT_ARG->i;
		OP* padop;
		switch (target_type)
		{
			case 0: // undef
			{
				if (is_hash && !key_op)
				{
					Perl_qerror(aTHX_ mess("explicit discard (undef target) requires explicit hash key"));
				}
				padop = newOP(OP_UNDEF, 0);
				break;
			}
			case 1: // lexvar (not ref)
			{
				PADOFFSET padix = (PADOFFSET)(NEXT_ARG->i);
				SV* padsv = PAD_SVl(padix);
				assert(padsv);
				const svtype padsvtype = SvTYPE(padsv);
				if (padsvtype == SVt_PVHV)
				{
					/* Hash slurper */
					if (!is_hash)
					{
						// Syntax stgructure should not have allowed this.
						warn("Internal error - hash slurp target not allowed for array source");
						assert(0);
						Perl_qerror(aTHX_ mess("Hash slurp target not allowed for array source"));
					}
					if (key_op)
					{
						Perl_qerror(aTHX_ mess("Partial destructure to hash is not yet supported (are you missing a \\?)"));
					}
					padop = newOP(OP_PADHV, OPf_REF|OPf_MOD|(OPpLVAL_INTRO << 8));
					padop->op_targ = padix;
					op_private |= OPpRESTHV;
				}
				else if (padsvtype == SVt_PVAV)
				{
					if (key_op)
					{
						Perl_qerror(aTHX_ mess("Partial destructure to array is not yet supported (are you missing a \\?)"));
					}
					padop = newOP(OP_PADAV, OPf_REF|OPf_MOD|(OPpLVAL_INTRO << 8));
					padop->op_targ = padix;
					op_private |= OPpRESTAV;
				}
				else
				{
					assert(padsvtype < SVt_PVAV);
					assert(is_hash || !key_op);
					if (is_hash && !key_op)
					{
						char* name = PadnamePV(PadnamelistARRAY(PL_comppad_name)[padix]);
						SV* sv = newSVpv(name + 1, 0);
						SvREADONLY_on(sv);
						key_op = op_contextualize(newSVOP(OP_CONST, (OPpCONST_BARE << 8), sv), G_SCALAR);
					}
					padop = newOP(OP_PADSV, OPf_REF|OPf_MOD|(OPpLVAL_INTRO << 8));
					padop->op_targ = padix;
				}
				break;
			}
			case 2: // Lexvar byref
			{
				/* Obey use feature 'declared_refs'; */
				#ifdef FEATURE_MYREF_IS_ENABLED
				if (!FEATURE_MYREF_IS_ENABLED)
				{
					Perl_croak(aTHX_ "The experimental declared_refs feature is not enabled");
				}
				Perl_ck_warner_d(aTHX_ packWARN(WARN_EXPERIMENTAL__DECLARED_REFS), "Declaring references is experimental");
				#endif
				PADOFFSET padix = (PADOFFSET)(NEXT_ARG->i);
				DBG("Pad offset is %ld out of %ld", padix, PadMAX(PL_comppad));
				SV* padsv = PAD_SVl(padix);
				assert(is_hash || !key_op);
				if (is_hash && !key_op)
				{
					char* name = PadnamePV(PadnamelistARRAY(PL_comppad_name)[padix]);
					SV* sv = newSVpv(name + 1, 0);
					SvREADONLY_on(sv);
					key_op = op_contextualize(newSVOP(OP_CONST, (OPpCONST_BARE << 8), sv), G_SCALAR);
				}
				switch (SvTYPE(padsv))
				{
					case SVt_PVHV:
						padop = newOP(OP_PADHV, OPf_REF|OPf_MOD|(OPpLVAL_INTRO << 8));
						break;
					case SVt_PVAV:
						padop = newOP(OP_PADAV, OPf_REF|OPf_MOD|(OPpLVAL_INTRO << 8));
						break;
					default:
						padop = newOP(OP_PADSV, OPf_REF|OPf_MOD|(OPpLVAL_INTRO << 8));
						break;
				}
				padop->op_targ = padix;
				padop = op_contextualize(padop, G_ARRAY);
				padop = op_contextualize(newLISTOP(OP_LIST, 0, padop, NULL), G_ARRAY);
				padop = newUNOP(OP_REFGEN, 0, padop);
				break;
			}
			case 3:
			{
				padop = build_let_varlist(aTHX_ args, nargs, argix, hookdata, 1);
				padop->op_type = OP_CUSTOM;
				padop->op_ppaddr = pp_nestedlet;
				padop->op_private |= OPpNESTEDHV;
				padop = op_contextualize(padop, G_ARRAY);
				// Do not waste time doing a mask check for OP_CUSTOM: build_let will do it at the end. And if it was masked here it'll be masked there.
				break;
			}
			case 4:
			{
				padop = build_let_varlist(aTHX_ args, nargs, argix, hookdata, 1);
				padop->op_type = OP_CUSTOM;
				padop->op_ppaddr = pp_nestedlet;
				padop->op_private |= OPpNESTEDAV;
				padop = op_contextualize(padop, G_ARRAY);
				// Do not waste time doing a mask check for OP_CUSTOM: build_let will do it at the end. And if it was masked here it'll be masked there.
				break;
			}
		}
		// PADAV/PADHV must be in list context, the others can be scalar
		if (padop->op_type == OP_PADAV || padop->op_type == OP_PADHV)
			padop = op_contextualize(padop, G_ARRAY);
		else
			padop = op_contextualize(padop, G_SCALAR);
		padop = op_lvalue(padop, OP_AASSIGN);
		if (key_op) op_append_elem(OP_LIST, oplist, key_op);
		op_append_elem(OP_LIST, oplist, padop);
	}
	oplist->op_private = op_private;
	return oplist;
}

static int build_let(pTHX_ OP** out, XSParseKeywordPiece* args[], size_t nargs, void* hookdata)
{
	OP* oplist;
	
	size_t argix = 0;
	I32 toplevel = args[argix++]->i;
	switch (toplevel)
	{
		case 0: // round parens
		case 1: // curly braces
		{
			oplist = build_let_varlist(aTHX_ args, nargs, &argix, hookdata, 1);
			break;
		}
		case 2: // square brackets
		{
			oplist = build_let_varlist(aTHX_ args, nargs, &argix, hookdata, 0);
			break;
		}
	}
	OP* srcop;
	if (toplevel == 0)
	{
		srcop = op_contextualize((my_next_arg(aTHX_ args, nargs, &argix))->op, G_ARRAY);
		// Implicit hash, so if the expression isn't already a hash, make it one.
		switch (srcop->op_type)
		{
			case OP_PADHV:
			case OP_RV2HV:
				srcop->op_flags |= OPf_REF;
				break;
			default:
			{
				/* Wrap an arbitrary list into a hash construct and dereference */
				OP* hashop = newLISTOP(OP_LIST, 0, (OP*)0, (OP*)0);
				hashop = op_append_elem(OP_LIST, hashop, srcop);
				hashop = op_convert_list(OP_ANONHASH, 0, hashop);
				srcop = op_contextualize(newUNOP(OP_RV2HV, OPf_REF, hashop), G_ARRAY);
			}
			break;
		}
		oplist = op_append_elem(OP_LIST, oplist, srcop);
	}
	else
	{
		// Explicit target
		srcop = op_contextualize((my_next_arg(aTHX_ args, nargs, &argix))->op, G_SCALAR); // SCALAR CONTEXT!
		oplist->op_type = OP_CUSTOM;
		oplist->op_ppaddr = pp_nestedlet;
		oplist->op_private |= (toplevel == 1) ? OPpNESTEDHV : OPpNESTEDAV;
		oplist = op_contextualize(oplist, G_ARRAY);
		oplist = newLISTOP(OP_LIST, 0, oplist, NULL);
		oplist = op_append_elem(OP_LIST, oplist, srcop);
	}
	
	oplist->op_type = OP_CUSTOM;
	if (toplevel != 0) oplist->op_flags |= OPf_SPECIAL;
	oplist->op_ppaddr = pp_destructure;
	if (PL_op_mask && PL_op_mask[OP_CUSTOM])
	{
		op_free(oplist);
		croak("destructure' trapped by operation mask");
	}
	else
		oplist = PL_check[OP_CUSTOM](aTHX_ oplist); // Does this even do anything?

	*out = oplist;
	return KEYWORD_PLUGIN_EXPR;
}

static const struct XSParseKeywordPieceType pieces_let[] = {
	XPK_CHOICE(
		XPK_PARENSCOPE(
			XPK_COMMALIST(
				XPK_OPTIONAL(
					XPK_CHOICE(
						XPK_IDENT,
						XPK_BRACESCOPE(XPK_TERMEXPR_SCALARCTX)
					),
					XPK_LITERAL("=>")
				),
				#if 0
				XPK_CHOICE(
					XPK_LITERAL("undef"),
				#endif
					XPK_LEXVAR_MY(XPK_LEXVAR_SCALAR | XPK_LEXVAR_HASH | XPK_LEXVAR_ARRAY)
				#if 0
					,
					XPK_SEQUENCE(XPK_LITERAL("\\"), XPK_LEXVAR_MY(XPK_LEXVAR_ANY)),
					XPK_BRACESCOPE(
						XPK_COMMALIST(
							XPK_OPTIONAL(
								XPK_CHOICE(
									XPK_IDENT,
									XPK_BRACESCOPE(XPK_TERMEXPR_SCALARCTX)
								),
								XPK_LITERAL("=>")
							),
							XPK_CHOICE(
								XPK_LITERAL("undef"),
								XPK_LEXVAR_MY(XPK_LEXVAR_SCALAR | XPK_LEXVAR_HASH)
							)
						)
					),
					XPK_BRACKETSCOPE(
						XPK_COMMALIST(
							XPK_CHOICE(
								XPK_LITERAL("undef"),
								XPK_LEXVAR_MY(XPK_LEXVAR_SCALAR | XPK_LEXVAR_ARRAY)
							)
						)
					)
				)
				#endif
			)
		),
		XPK_BRACESCOPE(
			XPK_COMMALIST(
				XPK_OPTIONAL(
					XPK_CHOICE(
						XPK_IDENT,
						XPK_BRACESCOPE(XPK_TERMEXPR_SCALARCTX)
					),
					XPK_LITERAL("=>")
				),
				#if 0
				XPK_CHOICE(
					XPK_LITERAL("undef"),
				#endif
					XPK_LEXVAR_MY(XPK_LEXVAR_SCALAR | XPK_LEXVAR_HASH)
				#if 0
					,
					XPK_SEQUENCE(XPK_LITERAL("\\"), XPK_LEXVAR_MY(XPK_LEXVAR_ANY)),
					XPK_BRACESCOPE(
						XPK_COMMALIST(
							XPK_OPTIONAL(
								XPK_CHOICE(
									XPK_IDENT,
									XPK_BRACESCOPE(XPK_TERMEXPR_SCALARCTX)
								),
								XPK_LITERAL("=>")
							),
							XPK_CHOICE(
								XPK_LITERAL("undef"),
								XPK_LEXVAR_MY(XPK_LEXVAR_SCALAR | XPK_LEXVAR_HASH)
							)
						)
					),
					XPK_BRACKETSCOPE(
						XPK_COMMALIST(
							XPK_CHOICE(
								XPK_LITERAL("undef"),
								XPK_LEXVAR_MY(XPK_LEXVAR_SCALAR | XPK_LEXVAR_ARRAY)
							)
						)
					)
				)
				#endif
			)
		),
		XPK_BRACKETSCOPE(
			XPK_COMMALIST(
				#if 0
				XPK_CHOICE(
					XPK_LITERAL("undef"),
				#endif
					XPK_LEXVAR_MY(XPK_LEXVAR_SCALAR | XPK_LEXVAR_ARRAY)
				#if 0
					,
					XPK_SEQUENCE(XPK_LITERAL("\\"), XPK_LEXVAR_MY(XPK_LEXVAR_ANY)),
					XPK_BRACESCOPE(
						XPK_COMMALIST(
							XPK_OPTIONAL(
								XPK_CHOICE(
									XPK_IDENT,
									XPK_BRACESCOPE(XPK_TERMEXPR_SCALARCTX)
								),
								XPK_LITERAL("=>")
							),
							XPK_CHOICE(
								XPK_LITERAL("undef"),
								XPK_LEXVAR_MY(XPK_LEXVAR_SCALAR | XPK_LEXVAR_HASH)
							)
						)
					),
					XPK_BRACKETSCOPE(
						XPK_COMMALIST(
							XPK_CHOICE(
								XPK_LITERAL("undef"),
								XPK_LEXVAR_MY(XPK_LEXVAR_SCALAR | XPK_LEXVAR_ARRAY)
							)
						)
					)
				)
				#endif
			)
		)
	),
	XPK_EQUALS,
	XPK_TERMEXPR
};

static const struct XSParseKeywordHooks kwhooks_let = {
	.permit_hintkey = "Syntax::Keyword::Let",
	.pieces = pieces_let,
	.build = build_let,
};

MODULE = Syntax::Keyword::Let  PACKAGE = Syntax::Keyword::Let

BOOT:
	boot_xs_parse_keyword(0);
	
	XopENTRY_set(&xop_destructure, xop_name, "destructure");
	XopENTRY_set(&xop_destructure, xop_desc, "deconstruct hash");
	XopENTRY_set(&xop_destructure, xop_class, OA_LISTOP);
	Perl_custom_op_register(aTHX_ &pp_destructure, &xop_destructure);
	
	XopENTRY_set(&xop_nestedlet, xop_name, "nestedlet");
	XopENTRY_set(&xop_nestedlet, xop_desc, "nested let section");
	XopENTRY_set(&xop_nestedlet, xop_class, OA_LISTOP);
	Perl_custom_op_register(aTHX_ &pp_nestedlet, &xop_nestedlet);

	register_xs_parse_keyword("let", &kwhooks_let, (void*)0);

